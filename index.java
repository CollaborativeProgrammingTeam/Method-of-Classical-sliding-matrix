Программа представляет собой полноценную систему регрессионного анализа с возможностью прогнозирования и статистической проверки результатов.
import Jama.Matrix; // Импорт библиотеки для работы с матрицами
import java.util.Objects; // Содержит вспомогательные статические методы для работы
		              с объектами
import java.util.Scanner; // Предназначен для чтения ввода данных от пользователя
                                            из различных источников
public class MyProgramm {
    public static void main(String[] args) {
        // Матрица независимых переменных X размером 20x5
        // Каждая строка представляет один день наблюдения
        // Столбцы: [1, x1, x1^2, x3, x1*x3] - признаки для регрессии
        double[][] X = {
                {1, 1, 1, 21.5, 21.5},      // День 1: константа, время, время^2, температура, 
                                                          время*температура
                {1, 2, 4, 21.2, 42.4},      // День 2
                {1, 3, 9, 22.1, 66.3},      // День 3
                {1, 4, 16, 25.1, 100.4},    // День 4
                {1, 5, 25, 26.4, 132},      // День 5
                {1, 6, 36, 22.6, 135.6},    // День 6
                {1, 7, 49, 17.7, 123.9},    // День 7
                {1, 8, 64, 18.5, 148},      // День 8
                {1, 9, 81, 21.2, 190.8},    // День 9
                {1, 10, 100, 20.3, 203},    // День 10
                {1, 11, 121, 17, 187},      // День 11
                {1, 12, 144, 19.2, 230.4},  // День 12
                {1, 13, 169, 19.4, 252.2},  // День 13
                {1, 14, 196, 21.9, 306.6},  // День 14
                {1, 15, 225, 25.5, 382.5},  // День 15
                {1, 16, 256, 26.3, 420.8},  // День 16
                {1, 17, 289, 26.3, 447.1},  // День 17
                {1, 18, 324, 24.7, 444.6},  // День 18
                {1, 19, 361, 21.4, 406.6},  // День 19
                {1, 20, 400, 21.04, 420.8}  // День 20
        };

        // Вектор зависимой переменной Y - целевые значения (например, продажи)
        double[] Y = {
                2357.85,  // Значение Y для дня 1
                2669.7,   // День 2
                2669.7,   // День 3
                2998.05,  // День 4
                3512.85,  // День 5
                3542.55,  // День 6
                3248.85,  // День 7
                3341.25,  // День 8
                3453.45,  // День 9
                3598.65,  // День 10
                3413.85,  // День 11
                4271.85,  // День 12
                4393.95,  // День 13
                3686.1,   // День 14
                3682.8,   // День 15
                3550.8,   // День 16
                4719,     // День 17
                3979.35,  // День 18
                4131.6,   // День 19
                4141.5    // День 20
        };
        
        // Основной цикл программы - меню взаимодействия с пользователем
        while (true) {
            System.out.println("Введите действие\n1. Сделать расчёт на завтрашний день\n2. Сделать расчёт на следующие дни \n3. Выйти из системы");
            Scanner print = new Scanner(System.in);
            String choice = print.nextLine();
            
            // Опция 1: Прогноз на следующий день без обновления данных
            if (Objects.equals(choice, "1")) {
                System.out.println("Введите прогнозирующую температуру на следующий день");
                double A = print.nextDouble(); // Получаем прогнозируемую температуру
                double YP = find_YP(X, Y, A); // Вызываем функцию прогнозирования
            }
            
            // Опция 2: Прогноз с обновлением данных (скользящее окно)
            if (Objects.equals(choice, "2")) {
                System.out.println("Введите последовательно новые значения x0, x1, x2, x3, x4, y0");
                // Получаем новые данные для обновления матриц
                double x0 = print.nextDouble(); // Константа (обычно 1)
                double x1 = print.nextDouble(); // Время (номер дня)
                double x2 = print.nextDouble(); // Квадрат времени
                double x3 = print.nextDouble(); // Температура
                double x4 = print.nextDouble(); // Произведение времени и температуры
                double y0 = print.nextDouble(); // Новое значение целевой переменной
                
                System.out.println("Введите прогнозирующую температуру на следующий день");
                double A = print.nextDouble(); // Прогнозируемая температура
                
                // Обновляем матрицы методом скользящего окна (удаляем старые данные, добавляем новые)
                double[][] slidingMatrix_X = create_sliding_matrix_part_x(X, x0, x1, x2, x3, x4);
                double[] slidingMatrix_Y = create_sliding_matrix_part_y(Y, y0);
                
                // Выполняем прогноз с обновленными данными
                double YP = find_YP(slidingMatrix_X, slidingMatrix_Y, A);
            }
            
            // Опция 3: Выход из программы
            if (Objects.equals(choice, "3")) {
                System.out.println("Программа окончена");
                break; // Выход из цикла while
            }
        }
    }

    /**
     * Функция обновления матрицы X методом скользящего окна
     * Удаляет самую старую строку и добавляет новую в конец
     */
    public static double[][] create_sliding_matrix_part_x(double[][] X, double x0, double x1, double x2, double x3, double x4) {
        // Сдвигаем все строки вверх (удаляем первую строку)
        for (int i = 0; i < X.length - 1; i++) {
            X[i] = X[i + 1];
        }
        // Добавляем новую строку в конец матрицы
        X[19] = new double[]{x0, x1, x2, x3, x4};
        return X;
    }

    /**
     * Функция обновления вектора Y методом скользящего окна
     * Удаляет самое старое значение и добавляет новое в конец
     */
    public static double[] create_sliding_matrix_part_y(double[] Y, double y0) {
        // Сдвигаем все элементы влево (удаляем первый элемент)
        for (int i = 0; i < Y.length - 1; i++) {
            Y[i] = Y[i + 1];
        }
        // Добавляем новое значение в конец вектора
        Y[19] = y0;
        return Y;
    }
    /**
     * Основная функция построения регрессионной модели и прогнозирования
     * @param X - матрица независимых переменных
     * @param Y - вектор зависимой переменной
     * @param A - прогнозируемая температура для следующего дня
     * @return YP - прогнозируемое значение зависимой переменной
     */
    public static double find_YP(double[][] X, double[] Y, double A) {
        long startTime = System.nanoTime(); // Засекаем время начала выполнения
        int N = 20; // Количество наблюдений
        int k = 5;  // Количество параметров в модели (включая константу)

        // СОЗДАНИЕ МАТРИЦ ДЛЯ РАСЧЕТОВ
        // Преобразуем массивы в объекты Matrix библиотеки JAMA
        Matrix matrixX = new Matrix(X);      // Матрица независимых переменных (20x5)
        Matrix matrixY = new Matrix(Y, Y.length); // Вектор зависимой переменной (20x1)

        // МЕТОД НАИМЕНЬШИХ КВАДРАТОВ
        // Вычисляем коэффициенты регрессии: B = (X^T * X)^-1 * X^T * Y
        Matrix matrixXT = matrixX.transpose();        // Транспонированная матрица X (5x20)
        Matrix matrixXTX = matrixXT.times(matrixX);   // X^T * X (5x5)
        Matrix matrixXTXInv = matrixXTX.inverse();    // (X^T * X)^-1 - обратная матрица (5x5)
        Matrix matrixXTY = matrixXT.times(matrixY);   // X^T * Y (5x1)
        Matrix B = matrixXTXInv.times(matrixXTY);     // Коэффициенты регрессии B (5x1)

        // ВЫВОД РЕЗУЛЬТАТОВ РЕГРЕССИИ
        System.out.println("Коэффициенты регрессии:");
        B.print(5, 3); // Выводим коэффициенты с 5 знаками до и 3 после запятой

        // РАСЧЕТ ПРЕДСКАЗАННЫХ ЗНАЧЕНИЙ И ОСТАТКОВ
        Matrix YR = matrixX.times(B); // Рассчитываем предсказанные значения Y_R = X * B
        System.out.println("Перемножение матриц (предсказанные значения Y_R):");
        YR.print(5, 3);

        // Вычисляем остатки (разницы между фактическими и предсказанными значениями)
        Matrix residuals = matrixY.minus(YR);

        // ДИСПЕРСИОННЫЙ АНАЛИЗ
        // Сумма квадратов остатков - мера ошибки модели
        double sumOfSquares = 0.0;
        for (int i = 0; i < residuals.getRowDimension(); i++) {
            sumOfSquares += Math.pow(residuals.get(i, 0), 2);
        }

        // Оценка дисперсии ошибок (остаточная дисперсия)
        double Dad = sumOfSquares / (N - k);
        System.out.printf("Значение Dad (остаточная дисперсия): %.3f%n", Dad);

        // Вычисляем среднее арифметическое фактических значений Y
        double sumY = 0.0;
        for (double value : Y) {
            sumY += value;
        }
        double YSR = sumY / N;
        System.out.printf("Средняя арифметическая YSR: %.3f%n", YSR);

        // Вычисляем общую дисперсию зависимой переменной
        double sumSquaredDifferences = 0.0;
        for (double value : Y) {
            sumSquaredDifferences += Math.pow(value - YSR, 2);
        }
        double DY = sumSquaredDifferences / (N - 1);
        System.out.printf("Дисперсия зависимой переменной DY: %.3e%n", DY);

        // F-ТЕСТ ДЛЯ ПРОВЕРКИ АДЕКВАТНОСТИ МОДЕЛИ
        // Сравниваем объясненную дисперсию с остаточной
        double FR = DY / Dad;
        System.out.printf("Расчетное значение FR (F-статистика): %.3f%n", FR);

        double F = 2.34; // Табличное значение F-критерия Фишера для заданных степеней свободы
        System.out.println();
        
        // Проверяем значимость модели
        if (FR > F) {
            System.out.println("Расчетное значение F превышает табличное значение F. Модель адекватна.");
        } else {
            System.out.println("Расчетное значение F не превышает табличное значение F. Модель неадекватна.");
        }

        // РАСЧЕТ КОРРЕЛЯЦИИ МЕЖДУ ФАКТИЧЕСКИМИ И ПРЕДСКАЗАННЫМИ ЗНАЧЕНИЯМИ
        // Вычисляем среднее предсказанных значений
        double meanYR = 0.0;
        for (int i = 0; i < N; i++) {
            meanYR += YR.get(i, 0);
        }
        meanYR /= N;

        // Вычисляем коэффициент корреляции Пирсона
        double numerator = 0.0;    // Числитель формулы корреляции
        double denominatorY = 0.0; // Сумма квадратов отклонений Y
        double denominatorYR = 0.0; // Сумма квадратов отклонений Y_R
        
        for (int i = 0; i < N; i++) {
            double diffY = Y[i] - YSR;           // Отклонение фактического Y от среднего
            double diffYR = YR.get(i, 0) - meanYR; // Отклонение предсказанного Y от среднего

            numerator += diffY * diffYR;                    // Ковариация
            denominatorY += Math.pow(diffY, 2);            // Дисперсия Y
            denominatorYR += Math.pow(diffYR, 2);          // Дисперсия Y_R
        }

        double correlation = numerator / Math.sqrt(denominatorY * denominatorYR);
        System.out.printf("Коэффициент корреляции между Y и Y_R: %.3f%n", correlation);

        // ДОВЕРИТЕЛЬНЫЕ ИНТЕРВАЛЫ ДЛЯ ПАРАМЕТРОВ
        Matrix G = matrixXTXInv; // Матрица ковариации коэффициентов

        System.out.println("\nМатрица G (ковариационная матрица коэффициентов):");
        G.print(8, 6);

        double t = 2.131; // Табличное значение t-статистики Стьюдента для доверительной вероятности
        System.out.println("Табличное значение t-статистики = " + t);
        
        // Матрица проекции (матрица влияния)
        Matrix D = matrixX.times(G).times(matrixXT);
        System.out.println("Матрица D (матрица проекции):");
        D.print(8, 6);

        // РАСЧЕТ СТАНДАРТНЫХ ОШИБОК ПРОГНОЗА
        double[] S = new double[N]; // Массив стандартных ошибок прогноза для каждого наблюдения
        
        for (int i = 0; i < N; i++) {
            double Di_i = D.get(i, i); // Диагональный элемент матрицы D (мера влияния наблюдения)
            S[i] = t * Math.sqrt(Dad * (1 + Di_i)); // Стандартная ошибка прогноза
        }

        System.out.println("Массив S (стандартные ошибки прогноза):");
        for (double value : S) {
            System.out.printf("%.3f%n", value);
        }

        // ДОВЕРИТЕЛЬНЫЕ ИНТЕРВАЛЫ ДЛЯ КОЭФФИЦИЕНТОВ РЕГРЕССИИ
        double delta0 = t * Math.sqrt(Dad * G.get(0, 0)); // Для коэффициента β0
        double delta1 = t * Math.sqrt(Dad * G.get(1, 1)); // Для коэффициента β1
        double delta2 = t * Math.sqrt(Dad * G.get(2, 2)); // Для коэффициента β2
        double delta3 = t * Math.sqrt(Dad * G.get(3, 3)); // Для коэффициента β3
        double delta4 = t * Math.sqrt(Dad * G.get(4, 4)); // Для коэффициента β4
        
        System.out.printf("Δ0 (доверительный интервал для β0) = %.3f%n", delta0);
        System.out.printf("Δ1 (доверительный интервал для β1) = %.3f%n", delta1);
        System.out.printf("Δ2 (доверительный интервал для β2) = %.3f%n", delta2);
        System.out.printf("Δ3 (доверительный интервал для β3) = %.3f%n", delta3);
        System.out.printf("Δ4 (доверительный интервал для β4) = %.3f%n", delta4);

        // ПРОГНОЗИРОВАНИЕ
        // Определяем время для прогноза (следующий день после последнего наблюдения)
        double tau = X[19][1] + 1; // Время = последнее время + 1 день

        // Создаем матрицу предикторов для прогноза
        double[][] XPArray = {
                {1, tau, Math.pow(tau, 2), A, tau * A} // [константа, время, время^2, температура, время*температура]
        };

        Matrix XP = new Matrix(XPArray); // Матрица предикторов для прогноза

        // Вычисляем транспонированную матрицу (для демонстрации)
        Matrix XPT = XP.transpose();
        System.out.println("Транспонированная матрица XP^T:");
        XPT.print(5, 3);

        // ВЫЧИСЛЯЕМ ПРОГНОЗИРУЕМОЕ ЗНАЧЕНИЕ
        // YP = β0 + β1*τ + β2*τ^2 + β3*A + β4*τ*A
        double YP = B.get(0, 0) +                    // β0 (константа)
                   B.get(1, 0) * tau +              // β1 * время
                   B.get(2, 0) * Math.pow(tau, 2) + // β2 * время^2
                   B.get(3, 0) * A +                // β3 * температура
                   B.get(4, 0) * tau * A;           // β4 * время * температура

        // ВЫВОД РЕЗУЛЬТАТОВ ПРОГНОЗА
        System.out.printf("Расчетное значение YP: %.3f%n", YP);
        
        // Доверительный интервал прогноза
        double Ymax = YP + S[19]; // Верхняя граница
        double Ymin = YP - S[19]; // Нижняя граница
        
        System.out.println("Верхняя граница коридора: " + Ymax);
        System.out.println("Нижняя граница коридора: " + Ymin);

        // ИЗМЕРЕНИЕ ВРЕМЕНИ ВЫПОЛНЕНИЯ
        long endTime = System.nanoTime();
        long duration = endTime - startTime;
        double durationInMs = duration / 1_000_000.0;
        System.out.println("Время выполнения: " + durationInMs + " миллисекунд");
        
        return YP; // Возвращаем прогнозируемое значение
    }
}
